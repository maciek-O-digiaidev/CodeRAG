/**
 * FirstRunDialog â€” multi-step configuration wizard for CodeRAG.
 *
 * Shows on first activation in a new workspace (tracked via globalState).
 * Guides the user through:
 *   1. Welcome + project detection
 *   2. Embedding provider selection
 *   3. AI agent detection + MCP auto-config opt-in
 *   4. Generate config + start indexing option
 *
 * Can be re-opened on demand via `CodeRAG: Configure` command.
 */

import type * as vscode from 'vscode';
import { readFile, writeFile, mkdir } from 'node:fs/promises';
import { join } from 'node:path';
import { detectAllAgents } from './agent-detector.js';
import type { AgentDetectionResult, AgentId } from './agent-detector.js';
import { getFirstRunDialogHtml } from './first-run-dialog-html.js';

/** globalState key to track whether first-run setup has been completed. */
const FIRST_RUN_COMPLETED_KEY = 'coderag.firstRunCompleted';

/** Embedding provider choices. */
export type EmbeddingProvider = 'ollama' | 'voyage' | 'openai';

/** User choices collected from the wizard. */
export interface FirstRunConfig {
  readonly embeddingProvider: EmbeddingProvider;
  readonly agentConfigs: ReadonlyMap<AgentId, boolean>;
  readonly startIndexing: boolean;
}

/** Message from the webview to the extension host. */
export type FirstRunWebviewMessage =
  | { readonly type: 'ready' }
  | { readonly type: 'detect-agents' }
  | { readonly type: 'complete'; readonly config: FirstRunConfigPayload }
  | { readonly type: 'cancel' };

/** JSON-serializable config payload from the webview. */
export interface FirstRunConfigPayload {
  readonly embeddingProvider: EmbeddingProvider;
  readonly agentConfigs: Record<string, boolean>;
  readonly startIndexing: boolean;
}

/** Message from the extension host to the webview. */
export type FirstRunExtensionMessage =
  | { readonly type: 'workspace-info'; readonly data: WorkspaceInfo }
  | { readonly type: 'agents-detected'; readonly agents: readonly AgentDetectionResult[] };

/** Workspace detection information. */
export interface WorkspaceInfo {
  readonly workspaceName: string;
  readonly hasCoderagYaml: boolean;
  readonly hasPackageJson: boolean;
  readonly hasCargoToml: boolean;
  readonly hasGoMod: boolean;
  readonly hasPyprojectToml: boolean;
}

/** MCP server configuration entry. */
interface McpServerConfig {
  command: string;
  args: string[];
}

/** Shape of a settings.json file with mcpServers. */
interface McpSettingsJson {
  mcpServers?: Record<string, McpServerConfig>;
  [key: string]: unknown;
}

/**
 * Check whether the first-run dialog has been completed for this workspace.
 */
export function isFirstRunCompleted(context: vscode.ExtensionContext): boolean {
  return context.globalState.get<boolean>(FIRST_RUN_COMPLETED_KEY) === true;
}

/**
 * Mark the first-run dialog as completed.
 */
export async function markFirstRunCompleted(context: vscode.ExtensionContext): Promise<void> {
  await context.globalState.update(FIRST_RUN_COMPLETED_KEY, true);
}

/**
 * Reset the first-run completed flag (for testing or re-configuration).
 */
export async function resetFirstRunCompleted(context: vscode.ExtensionContext): Promise<void> {
  await context.globalState.update(FIRST_RUN_COMPLETED_KEY, false);
}

/**
 * Detect workspace characteristics.
 */
export async function detectWorkspace(
  workspaceRoot: string,
  workspaceName: string,
): Promise<WorkspaceInfo> {
  const checks = await Promise.all([
    fileExists(join(workspaceRoot, '.coderag.yaml')),
    fileExists(join(workspaceRoot, 'package.json')),
    fileExists(join(workspaceRoot, 'Cargo.toml')),
    fileExists(join(workspaceRoot, 'go.mod')),
    fileExists(join(workspaceRoot, 'pyproject.toml')),
  ]);

  return {
    workspaceName,
    hasCoderagYaml: checks[0] ?? false,
    hasPackageJson: checks[1] ?? false,
    hasCargoToml: checks[2] ?? false,
    hasGoMod: checks[3] ?? false,
    hasPyprojectToml: checks[4] ?? false,
  };
}

/**
 * Check if a file exists (safe, returns false on error).
 */
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await readFile(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Write or update .coderag.yaml with the selected embedding provider.
 */
export async function writeCoderagYaml(
  workspaceRoot: string,
  embeddingProvider: EmbeddingProvider,
): Promise<void> {
  const yamlPath = join(workspaceRoot, '.coderag.yaml');

  let content: string;
  try {
    content = await readFile(yamlPath, 'utf-8');
  } catch {
    content = '';
  }

  // If file is empty or doesn't exist, create a new one
  if (!content.trim()) {
    const providerConfig = getProviderYamlBlock(embeddingProvider);
    content = `# CodeRAG configuration\n# Generated by CodeRAG VS Code extension\n\nembedding:\n${providerConfig}\n`;
  }

  await writeFile(yamlPath, content, 'utf-8');
}

/**
 * Get the YAML block for a given embedding provider.
 */
function getProviderYamlBlock(provider: EmbeddingProvider): string {
  switch (provider) {
    case 'ollama':
      return '  provider: ollama\n  model: nomic-embed-text';
    case 'voyage':
      return '  provider: voyage\n  model: voyage-code-3';
    case 'openai':
      return '  provider: openai\n  model: text-embedding-3-small';
  }
}

/**
 * Write MCP server configuration for a specific agent.
 */
export async function writeMcpConfigForAgent(
  agentId: AgentId,
  agent: AgentDetectionResult,
  serverPort: number,
): Promise<void> {
  if (!agent.mcpConfigPath) {
    return;
  }

  const configDir = join(agent.mcpConfigPath, '..');
  await mkdir(configDir, { recursive: true });

  let existing: McpSettingsJson = {};
  try {
    const content = await readFile(agent.mcpConfigPath, 'utf-8');
    existing = JSON.parse(content) as McpSettingsJson;
  } catch {
    // File doesn't exist or is invalid, start fresh
  }

  const mcpServers: Record<string, McpServerConfig> = {
    ...(existing.mcpServers ?? {}),
  };
  mcpServers['coderag'] = {
    command: 'npx',
    args: ['coderag', 'serve', '--port', String(serverPort)],
  };
  existing.mcpServers = mcpServers;

  await writeFile(agent.mcpConfigPath, JSON.stringify(existing, null, 2) + '\n', 'utf-8');
}

/**
 * Apply the user's first-run configuration choices.
 */
export async function applyFirstRunConfig(
  config: FirstRunConfig,
  workspaceRoot: string,
  detectedAgents: readonly AgentDetectionResult[],
  serverPort: number,
): Promise<void> {
  // Write .coderag.yaml
  await writeCoderagYaml(workspaceRoot, config.embeddingProvider);

  // Write MCP configs for selected agents
  for (const [agentId, enabled] of config.agentConfigs) {
    if (!enabled) {
      continue;
    }
    const agent = detectedAgents.find((a) => a.id === agentId);
    if (agent?.installed && agent.mcpConfigPath) {
      await writeMcpConfigForAgent(agentId, agent, serverPort);
    }
  }
}

/**
 * Create and manage the first-run configuration dialog webview panel.
 */
export class FirstRunDialogPanel {
  private readonly panel: vscode.WebviewPanel;
  private readonly context: vscode.ExtensionContext;
  private readonly vscodeApi: typeof vscode;
  private readonly outputChannel: vscode.OutputChannel;
  private readonly workspaceRoot: string;
  private readonly serverPort: number;
  private detectedAgents: readonly AgentDetectionResult[] = [];
  private onCompleteCallback?: (config: FirstRunConfig) => void;
  private disposed = false;

  constructor(
    vscodeApi: typeof vscode,
    context: vscode.ExtensionContext,
    outputChannel: vscode.OutputChannel,
    workspaceRoot: string,
    serverPort: number,
  ) {
    this.vscodeApi = vscodeApi;
    this.context = context;
    this.outputChannel = outputChannel;
    this.workspaceRoot = workspaceRoot;
    this.serverPort = serverPort;

    this.panel = vscodeApi.window.createWebviewPanel(
      'coderag.firstRunDialog',
      'CodeRAG Setup',
      vscodeApi.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
      },
    );

    const nonce = generateNonce();
    this.panel.webview.html = getFirstRunDialogHtml(nonce);

    this.panel.webview.onDidReceiveMessage(
      (message: FirstRunWebviewMessage) => {
        void this.handleMessage(message);
      },
      undefined,
      context.subscriptions,
    );

    this.panel.onDidDispose(() => {
      this.disposed = true;
    });
  }

  /**
   * Set a callback for when the user completes the wizard.
   */
  onComplete(callback: (config: FirstRunConfig) => void): void {
    this.onCompleteCallback = callback;
  }

  /**
   * Check if the panel has been disposed.
   */
  isDisposed(): boolean {
    return this.disposed;
  }

  /**
   * Dispose the panel.
   */
  dispose(): void {
    if (!this.disposed) {
      this.panel.dispose();
      this.disposed = true;
    }
  }

  /**
   * Handle messages from the webview.
   */
  private async handleMessage(message: FirstRunWebviewMessage): Promise<void> {
    switch (message.type) {
      case 'ready': {
        await this.sendWorkspaceInfo();
        break;
      }

      case 'detect-agents': {
        await this.detectAndSendAgents();
        break;
      }

      case 'complete': {
        await this.handleComplete(message.config);
        break;
      }

      case 'cancel': {
        this.dispose();
        break;
      }
    }
  }

  /**
   * Detect workspace info and send to webview.
   */
  private async sendWorkspaceInfo(): Promise<void> {
    const workspaceName = this.vscodeApi.workspace.workspaceFolders?.[0]?.name ?? 'Unknown';
    const info = await detectWorkspace(this.workspaceRoot, workspaceName);
    this.postMessage({ type: 'workspace-info', data: info });
  }

  /**
   * Detect agents and send results to webview.
   */
  private async detectAndSendAgents(): Promise<void> {
    const extensionChecker = {
      isExtensionInstalled: (extensionId: string) => {
        return this.vscodeApi.extensions.getExtension(extensionId) !== undefined;
      },
    };

    this.detectedAgents = await detectAllAgents(extensionChecker);
    this.postMessage({ type: 'agents-detected', agents: this.detectedAgents });
  }

  /**
   * Handle the completion of the wizard.
   */
  private async handleComplete(payload: FirstRunConfigPayload): Promise<void> {
    try {
      const agentConfigs = new Map<AgentId, boolean>();
      for (const [key, value] of Object.entries(payload.agentConfigs)) {
        agentConfigs.set(key as AgentId, value);
      }

      const config: FirstRunConfig = {
        embeddingProvider: payload.embeddingProvider,
        agentConfigs,
        startIndexing: payload.startIndexing,
      };

      await applyFirstRunConfig(
        config,
        this.workspaceRoot,
        this.detectedAgents,
        this.serverPort,
      );

      await markFirstRunCompleted(this.context);

      this.outputChannel.appendLine('[first-run] Configuration completed successfully.');
      this.outputChannel.appendLine(`[first-run] Embedding provider: ${config.embeddingProvider}`);

      for (const [agentId, enabled] of config.agentConfigs) {
        if (enabled) {
          this.outputChannel.appendLine(`[first-run] MCP configured for: ${agentId}`);
        }
      }

      this.onCompleteCallback?.(config);
      this.dispose();
    } catch (error: unknown) {
      const message = error instanceof Error ? error.message : String(error);
      this.outputChannel.appendLine(`[first-run] Configuration failed: ${message}`);
      this.vscodeApi.window.showErrorMessage(`CodeRAG setup failed: ${message}`);
    }
  }

  /**
   * Post a message to the webview.
   */
  private postMessage(message: FirstRunExtensionMessage): void {
    if (!this.disposed) {
      void this.panel.webview.postMessage(message);
    }
  }
}

/**
 * Show the first-run dialog if it hasn't been completed yet.
 *
 * @param force - If true, show regardless of completion state (for re-configuration).
 * @returns The panel instance, or undefined if dialog was skipped.
 */
export function showFirstRunDialog(
  vscodeApi: typeof vscode,
  context: vscode.ExtensionContext,
  outputChannel: vscode.OutputChannel,
  workspaceRoot: string,
  serverPort: number,
  force = false,
): FirstRunDialogPanel | undefined {
  if (!force && isFirstRunCompleted(context)) {
    return undefined;
  }

  const panel = new FirstRunDialogPanel(
    vscodeApi,
    context,
    outputChannel,
    workspaceRoot,
    serverPort,
  );

  return panel;
}

/**
 * Register the `CodeRAG: Configure` command.
 */
export function registerConfigureCommand(
  vscodeApi: typeof vscode,
  context: vscode.ExtensionContext,
  outputChannel: vscode.OutputChannel,
  workspaceRoot: string,
  serverPort: number,
): void {
  const disposable = vscodeApi.commands.registerCommand('coderag.configure', () => {
    showFirstRunDialog(vscodeApi, context, outputChannel, workspaceRoot, serverPort, true);
  });
  context.subscriptions.push(disposable);
}

/**
 * Generate a random nonce string for Content Security Policy.
 */
function generateNonce(): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  for (let i = 0; i < 32; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}
