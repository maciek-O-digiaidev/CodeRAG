/**
 * CI reporter that generates GitHub PR comment markdown.
 *
 * Formats benchmark results, deltas, and regression status into a
 * markdown table suitable for posting as a PR comment via
 * `actions/github-script`.
 *
 * All functions are pure (no I/O, no side effects).
 */

import type {
  RegressionReport,
  MetricComparison,
  CIBenchmarkResult,
} from './types.js';
import { formatMetricName } from './regression-detector.js';

/**
 * Generate a full PR comment body from a regression report.
 *
 * Includes: status header, metrics table with deltas, and a summary.
 */
export function formatPRComment(report: RegressionReport): string {
  const lines: string[] = [];

  // Header with status indicator
  lines.push(formatHeader(report));
  lines.push('');

  // Metrics table
  lines.push(formatMetricsTable(report.comparisons, report.baseline !== null));
  lines.push('');

  // Run metadata
  lines.push(formatMetadata(report));
  lines.push('');

  // Footer
  lines.push('---');
  lines.push('*Generated by CodeRAG Benchmark CI*');

  return lines.join('\n');
}

/**
 * Format the status header with pass/fail indicator.
 */
export function formatHeader(report: RegressionReport): string {
  const lines: string[] = [];

  if (report.baseline === null) {
    lines.push('## Benchmark Results (First Run)');
    lines.push('');
    lines.push('No baseline found. These results will become the new baseline when merged to main.');
  } else if (report.hasRegression) {
    lines.push('## Benchmark Results - REGRESSION DETECTED');
    lines.push('');
    const regressed = report.comparisons.filter((c) => c.regressed);
    const metricNames = regressed.map((c) => formatMetricName(c.name)).join(', ');
    lines.push(
      `**${regressed.length} metric(s) regressed** beyond the ${report.thresholdPercent}% threshold: ${metricNames}`,
    );
  } else {
    lines.push('## Benchmark Results - PASSED');
    lines.push('');
    lines.push(
      `All metrics within ${report.thresholdPercent}% threshold of baseline.`,
    );
  }

  return lines.join('\n');
}

/**
 * Format the metrics comparison table.
 *
 * When no baseline exists, shows only the current values.
 * When a baseline exists, shows baseline, current, delta, and status columns.
 */
export function formatMetricsTable(
  comparisons: readonly MetricComparison[],
  hasBaseline: boolean,
): string {
  const lines: string[] = [];

  if (!hasBaseline) {
    // Simple table for first run
    lines.push('| Metric | Value |');
    lines.push('|--------|-------|');
    for (const c of comparisons) {
      lines.push(`| ${formatMetricName(c.name)} | ${fmt(c.current)} |`);
    }
  } else {
    // Full comparison table
    lines.push('| Metric | Baseline | Current | Delta | Status |');
    lines.push('|--------|----------|---------|-------|--------|');
    for (const c of comparisons) {
      const deltaStr = formatDelta(c);
      const status = formatStatus(c);
      lines.push(
        `| ${formatMetricName(c.name)} | ${fmt(c.baseline)} | ${fmt(c.current)} | ${deltaStr} | ${status} |`,
      );
    }
  }

  return lines.join('\n');
}

/**
 * Format the delta value with sign and percentage.
 */
export function formatDelta(comparison: MetricComparison): string {
  const sign = comparison.delta >= 0 ? '+' : '';
  return `${sign}${fmt(comparison.delta)} (${sign}${comparison.deltaPercent.toFixed(1)}%)`;
}

/**
 * Format the status indicator for a metric comparison.
 */
export function formatStatus(comparison: MetricComparison): string {
  if (comparison.regressed) {
    return 'REGRESSED';
  }
  if (comparison.delta > 0) {
    return 'improved';
  }
  if (comparison.delta === 0) {
    return 'unchanged';
  }
  return 'ok';
}

/**
 * Format the run metadata section.
 */
export function formatMetadata(report: RegressionReport): string {
  const lines: string[] = [];

  lines.push('<details>');
  lines.push('<summary>Run Details</summary>');
  lines.push('');
  lines.push(`- **Commit**: \`${report.current.commitSha}\``);
  lines.push(`- **Branch**: \`${report.current.branch}\``);
  lines.push(`- **Queries**: ${report.current.queryCount}`);
  lines.push(`- **Duration**: ${formatDuration(report.current.durationMs)}`);
  lines.push(`- **Seed**: ${report.current.seed}`);
  lines.push(`- **Timestamp**: ${report.current.timestamp}`);

  if (report.baseline !== null) {
    lines.push(`- **Baseline commit**: \`${report.baseline.commitSha}\``);
    lines.push(`- **Baseline date**: ${report.baseline.timestamp.split('T')[0] ?? report.baseline.timestamp}`);
  }

  lines.push('');
  lines.push('</details>');

  return lines.join('\n');
}

/**
 * Generate a short one-line summary suitable for CI status checks.
 */
export function formatStatusLine(report: RegressionReport): string {
  if (report.baseline === null) {
    return 'Benchmark: first run (no baseline), all metrics recorded';
  }

  if (report.hasRegression) {
    const regressed = report.comparisons.filter((c) => c.regressed);
    return `Benchmark: FAILED - ${regressed.length} metric(s) regressed beyond ${report.thresholdPercent}% threshold`;
  }

  return `Benchmark: PASSED - all metrics within ${report.thresholdPercent}% threshold`;
}

/**
 * Format a CIBenchmarkResult as a standalone markdown summary (no baseline comparison).
 */
export function formatStandaloneReport(result: CIBenchmarkResult): string {
  const lines: string[] = [];

  lines.push('## Benchmark Results');
  lines.push('');
  lines.push(`**Commit**: \`${result.commitSha}\` | **Branch**: \`${result.branch}\``);
  lines.push(`**Queries**: ${result.queryCount} | **Duration**: ${formatDuration(result.durationMs)}`);
  lines.push('');
  lines.push('| Metric | Value |');
  lines.push('|--------|-------|');

  const metricEntries: ReadonlyArray<readonly [string, number]> = [
    ['Precision@5', result.metrics.precisionAt5],
    ['Precision@10', result.metrics.precisionAt10],
    ['Recall@5', result.metrics.recallAt5],
    ['Recall@10', result.metrics.recallAt10],
    ['MRR', result.metrics.mrr],
    ['nDCG@10', result.metrics.ndcgAt10],
    ['MAP', result.metrics.map],
    ['Context Precision', result.metrics.contextPrecision],
  ];

  for (const [name, value] of metricEntries) {
    lines.push(`| ${name} | ${fmt(value)} |`);
  }

  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// Formatting helpers
// ---------------------------------------------------------------------------

function fmt(value: number): string {
  return value.toFixed(4);
}

function formatDuration(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  const seconds = ms / 1000;
  if (seconds < 60) return `${seconds.toFixed(1)}s`;
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
}
